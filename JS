JS
	JS基础
		js书写位置
			行内式
			内嵌式
			引入式
		输入输出语句
			弹框输出：alert（）
			弹框输入：prompt()
			控制台打印：console.log（）
		变量
			使用
				声明变量：var age //声明一个age的变量
				赋值：age=10 //把10这个值存入变量中
				输出结果：console.log(age)
				变量的初始化：将声明变量与赋值写在一行
var myname = ‘carly’；
console.log(myname);
			语法扩展
				更新变量
var address=18；
address=20；
console.log（address）；
输出结果为20
				声明多个变量，用逗号分隔开
var age=*，
      myname=*，
      sex=*；
				声明变量的特殊情况
					只声明不赋值：undefined
					不声明，不赋值：报错
					不声明，只赋值：可以使用，不建议，会变成全局变量
				变量命名规范
					1、变量命名必须以字母、下划线”_”或者”$”为开头。其他字符可以是字母、_、美元符号或数字。
2、变量名中不允许使用空格和其他标点符号，首个字不能为数字。
3、变量名长度不能超过255个字符。
4、变量名区分大小写。(javascript是区分大小写的语言)
5、变量名必须放在同一行中，名称要有意义，一般使用英文单词
6、不能使用脚本语言中保留的关键字（var、for、while、name）、保留字、true、false 和 null 作为标识符
7.驼峰命名法，首字母小写，后面的单词首字母大写，myFristName
				交换两个变量值
					利用temp临时变量进行交换
var temp；
var apple1=“青苹果”；
var apple2=“红苹果”；
temp=apple1；//把右边的给左边
apple1=apple2；
apple2=temp；
		数据类型
			js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的
var num=10 //num   属于数字类型；
var str=‘carly’ // str 属于字符串类型
			简单数据类型
				数字型 Number
					数字前加0，表示八进制
var num=010；  8
					数字前加0x，表示十六进制
var num=0xa；   10
					数字类型最大值
alert(Number.MAX_VALUE);
最小值
alert(Number.MIN_VALUE);
无穷大
alert（Infinity）
console.log(Number.MAX_VALUE)*2;
无穷小
alert（-Infinity）
console.log(Number.MIN_VALUE*2);
					非数值：NaN
					isNaN：用来判断是否为非数值类型
				字符串类型
					必须添加引号，内单外双或者内双外单
					字符串转义符
						\'	单引号
						\"	双引号
						\&	和号
						\\	反斜杠
						\n	换行符
						\r	回车符
						\t	制表符
						\b	退格符
						\f	换页符
					字符串长度：console.log(str.length)；
					字符串拼接 +，只要有字符串类型，拼接之后为新的字符串类型，数值相加，字符相连：
console.log('你好'+‘世界’+2021) //你好世界2021
conslole.log(12 + 12)  //24
				布尔类型
					值为true、false
					参与加减法运算时。true是1，false是0
					一个声明没有被赋值的变量会有一个默认值undefined（如果进行相加，字符串为字符串，有数值为NaN）
					一个声明变量给null值，里面的值为空，加数值为数值，加字符串为字符串
				获取变量类型
					typeof：var flag = true；
console.lohg(typeof flag) //boolean
flag = 1；
console.log(typeof flag) //number；
flag = null；
console.log(typeof flag) //object；
					字面量：是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值
数字字面量：8，9，0；
字符串字面量：‘你好’；
布尔字面量：true，false；
				数据类型转换
					转换为字符串
						toString（）转换成字符串
							var num=1；alert（num.toString()）;
						String（）强制转换
							var num=1；alert（String(num)）;
						隐式转换，加号拼接字符串，和字符串拼接的都是字符串
							var num=1；alert（num+‘我是字符串’）；
					转换为数字型
						parseInt（变量），得到的是整数，向下取整
						parseFloat（变量），可得到浮点数，小数
						Number（变量）
						隐式转换 算数运算 - * / ：var str=‘123’；console.log(str - 0)；//123
					转换为布尔型
						Boolean（）
代表空、否定的值换被转换为false，如（‘’、0、null、NaN、undefined）。
其余的值会被转换为true
				扩展
					编译型和解释型语言
					标识符：开发为变量、属性、函数、参数取的名字，标识符不能为关键字或保留字
关键字：指js本身已经使用了的字，break、case、catch、continue、var、while.........
保留字：预留的“关键字”，Boolean、class、float、goto、short、super........
			复杂数据类型
		运算符
			算数运算符
				加减乘除取余：+-*/%
				浮点数，会有精度误差
				表达式和返回值，由数字、运算符、变量等组成的式子，var num=1+1；//2
				递增简写，num=num+1   -->   num++
				前置递增运算符：先自加，后返回值，var num = 10；console.log（++num +10）；//21
				后置递增运算符：先返回值，后自加，var num = 10；console.log（num++ +10）；//20
console.log(num);//11
var e=10;
console.log(e++ + ++e);//22
				递减运算符与递增相似
			比较运算符
				<
				>
				=，赋值，将右边值赋予左边
				！=，不等于
				==,默认转换数据类型，会吧字符串型的数据转换为数字类型
console.log(18 == ‘18’) //true 
				===，值与数据类型的对比
console.log(18 === ‘18’) //false
			逻辑运算符
				&&，逻辑与，and，条件都为ture则true，有一条为false，则为false
				||，逻辑或，or，条件都为false则false，有一条为true，则为true
				！，not，逻辑非，取反， 
  console.log(!true)    //false
				短路运算（逻辑中断），当有多个表达式（值），左边的表达式值可以确定结果时，即停止不再运算
					逻辑与短路运算，表达式1，结果为真，则返回表达式2，表达式1为假，返回表达式1。
console.log(123&&456) //456
console.log(0&&123)      //0
有空的或者否定的为假（0 '' null undefined NaN），其余是真
					逻辑或短路运算，表达式1，结果为真，则返回表达式1，表达式1为假，返回表达式2。
console.log(123&&456) //123
console.log(0&&123)      //123

var num=0；
console.log(123 || num++)；   //123，结果为真true，不再执行num++，所以以下num答案为0
console.log(num)                    //0
			赋值运算符
				=，直接赋值
				+=、-=，加减一个数后再赋值 
var age=10；age+=5；//15
					age+=5  相当于 age=age+5；
				*=、/=、%= 乘、除、取模后再赋值
var age=2；age*=5；//10
					age*=5 相当于 age=age*5
			运算符优先级
				1.小括号        （）
2.一元运算符 ++ -- ！
3.算数运算符  先* / % 后+ -
4.关系运算符  > >= < <=
5.相等运算符  ==  !=  === !===
6.逻辑运算符  先&& 后||
7.赋值运算符  =
8.逗号运算符 ，
		流程控制
			顺序结构
			分支结构
				if分支语句
					if(条件表达式){
       //执行语句
}
if里的条件表达式结果为真，则执行大括号里的
条件表达式为假，则执行if分支往后的代码
					if(条件表达式){
       //执行语句1
} else｛
      //执行语句2
｝
if里的条件表达式结果为真，则执行语句1
条件表达式为假，则执行语句2，二选一执行
					if(条件表达式1){
       //执行语句1
} else  if（条件表达式2）｛
      //执行语句2
｝else if（条件表达式3）｛
      //执行语句3
｝else if（n）.....｛
｝else｛
      //执行语句n+1
｝
多选一，从上向下只要满足某一个条件表达式n，执行语句n，退出整个if分支语句
				三元表达式
					语法结构：条件表达式？ 表达式1：表达式2
执行思路：条件表达式结果为真，则返回表达式1的值，为假返回表达式2的值
var num=10；
。num>5 ？‘是的’：‘不是的’；//是的
						简化版if else分支选择
				switch分支语句
					switch（表达式）｛
      case value1：
               执行语句1；
               break；
      case value2：
               执行语句2；
               break；
       ....
       default：
               执行最后的语句；
｝
switch 转换，开关，case小例子或者选项的意思，拿着switch里的表达式(通常为变量)与value进行对比，匹配上了（全等于===）执行case后的语句，都没匹配上，则执行default里面的语句。
switch也是多分支语句，可实现多选一
					1）在开发中，表达式经常写成变量
2）表达式值与case的值相匹配的意思即为全等于 ===
3）case执行语句结束时，没有break，会继续执行下去直到有命令break出现或者到结束退出switch语句。
			循环结构
				for循环
					重复执行某些代码，跟计数有关系
					语法结构
for（初始化变量；条件表达式；操作表达式）｛
      //循环体
｝
初始化变量：用var声明的一个普通变量，同于计数器使用
条件表达式：用来决定每一次循环是否继续执行，即终止的条件
操作表达式：每次循环最后执行的代码，用于计数器变量进行更新（递增或者递减）
					for（var i = 1；i <= 100；i ++）{
        console.log(‘hello’)；
}
执行顺序
1）首先执行计数器变量，var i=1，且只执行一次，index
2）到i<=100判断是否满足条件，满足执行循环体，不满足退出循环
3）最后执行i++， i++是单独写的代码，递增
4）接着执行i<=100,满足条件执行循环体，不满足退出循环
						求和计数
var sum=0；
for（var i=1；i<=100;i++；）｛
     sum += i //sum=sum + i
｝
console.log(sum)
						打印台一行显示，追加字符串可实现
var str=”；
for （var i=1；i<=5；i++;）{
       str=str+‘hello’
}
console.log（str）；
					断点调试
						首先，给Sources里面的js文件打断点。点击你要调试的代码的行数，发现行数会被标记为蓝色（chrome），这说明已经成功打断点了
				双重for循环
					循环嵌套，在一个循环语句中嵌套for循环
					语法结构：
for（外层初始化变量；外层条件表达式；外层操作表达式）｛
   for（里层初始化变量；里层条件表达式；里层操作表达式）｛
             //执行语句；
｝
｝
里层的循环可以看做是外层循环的语句
外层每循环一次，里层的循环执行全部

				while循环
					语法结构
while（条件表达式）｛
     //循环体
｝
					当条件表达式结果为true，则执行循环体，否则退出
里面应该也有计数器，初始化变量
也有操作表达式，完成计数器的更新，防止死循环
var num=1；
while（num<=100)｛
       console.log('hello');
       num++；
｝
				do...while循环
					语法结构
do｛
   //循环体
｝while（条件表达式）

					跟while不同的地方在于do while 先执行一次循环体，再判断条件，条件为真，重复执行循环体，否则退出循环体
var i=1；
do｛
    console.log(‘hello’);
     i++;
｝while(i<=100)；
				continue  break
					continue 关键字
for （var i=1；i<=5；i++；）｛
      if（i == 3）｛
          continue；//遇到continue就退出本次循环，直接跳到i++;继续执行
｝
     console.log(‘这是第’ + i + ’次‘)
｝
					break 用于立即跳出整个循环（循环结束）
for （var i=1；i<=5；i++；）｛
      if（i == 3）｛
          break；//遇到break直接退出整个循环
｝
     console.log(‘这是第’ + i + ’次‘)
｝
		命名规范以及语法格式
			标识符命名规范
				变量、函数的命名要有意义
				变量的命名一般用名词
				函数的命名一般用动词
			操作符规范
				操作符左右两侧各保留一个空格
				var i = 1；
			单行注释规范
				单行注释前要有个空格
			其他规范
				括号左右保留空格     for （） ；
		数组
			数组概念
				数组指一组数据的集合，其中每个数据称为元素，在数组中可以存放任意类型的元素，数组存放在单个变量名下
变量只能存放一个数据
Array，可以把一组相关的数据一起存放，并提供方便的访问（获取）方式
			创建数组
				1）用new创建
var arr = new Array（）；
2）用数组字面量创建
var arr = [ ];
				数组的字面量是方括号 [ ]
数组中的数据用逗号隔开
声明数组并赋值称为数组的初始化
数组可以存放任意类型的数据，例如字符串，数字，布尔值等
			获取数组中的元素
				数组的索引（下标），用来访问数组元素的序号（数组下标从0开始）
				格式：数组名[索引号]；arr[i]
			遍历数组
				将数组中的元素全部访问一次
				var arr = [1，2，3]；
for （var i = 0，i <= arr.length; i++;） ｛
      console.log(arr [ i ]);
｝
				求数组中的最大值
var arr=[1，2，3，4]；
var max=arr[0];
for (var i = 1; i < arr.length; i++) {
   max = arr[i];
}
console.log('该数组中的最大值是' + max);
			数组中新增元素
				修改length长度新增数组元素
arr.length = i + 1;  
console.log(arr[i+1]);  //undefined
				追加数组元素，修改索引号，新增数组元素
arr[i+1]=‘X’；
若索引号被占用，则会修改替换数组元素
					新建一个存放1到10整数的数组
var arr=[];
for(var i = 0;i < 10; i++){
      arr[i]=i+1;
}
					筛选数组
var arr=[1,0,2,8,9,55,0,11];
var newArr=[];
for(var i=0; i < arr.length; i++){
     if(arr[i]>10){
           newArr[newArr.length]=arr[i]
}
}
			数组案例
				数组去重
					删除是0的数组元素
var arr=[2,0,4,8,3,0,9];
var newArr=[];
for (var i = 0; i < arr.length; i++) {
    if (arr[i] != 0) { 
    newArr[newArr.length]=arr[i];
}
}
				数组翻转
					var arr = [1，6，2，3，7，9];
var newArr=[];
for (var i = arr.length - 1;i >= 0; i--) {
     newArr[new.length] = arr[i]
}
				数组排序(冒泡排序)
					从小到大排序
var arr = [5,3,2,9,6,0,1];
for (var i = 0; i <= arr.length - 1; i++) {
     for (var j = 0; j <= arr.length - i - 1; j++ ) {
          if (arr[ j ] > arr[ j + 1 ]) {
              var temp = arr[ j ];
              arr[ j ] = arr[ j + 1 ];
              arr[ j + 1 ] = temp;
        }
    }
}
		函数
			函数概念
				封装一段可以重复执行调用的代码块，让大量代码重复使用
			函数使用
				声明函数
					function 函数名（形参1，形参2......）｛
   //函数体
｝

function getSum (num1,num2){
       var sum = 0；
       for (var i = num1; i < num2; i++ ) {
         sum += i;
   }
         console.log(sum)
}
				调用函数
					函数名（）；                      //getSum（）；
函数名(实参1，实参2....) ;  //getSum（1,100）;
					函数可以互相调用
function fn1（）｛
     con'sole.log(22)
｝
function fn2（）｛
  console.log(11)
  fn1（）；
｝
fn2（）；     // 11    22
			函数参数
				形参
					声明函数小括号里是形参：
function 函数名（形参1，形参2......）{}
调用函数时，形参接收实参，形参类似于一个变量，用逗号隔开
				实参
					调用函数小括号中是实参：
函数名（实参1，实参2......）;
				形参和实参的传递过程：在函数内部某些值不能固定，可以通过参数在调用函数时传递不同的值替代进去
				形参与实参个数不配的情况：
1）实参个数多于形参，只取到形参的个数，正常输出结果
2）实参个数少于形参，没得到传值的形参。变量空时定义为undefined，数字+undefined，结果为NaN
			函数返回值
				返回值格式
function 函数名（）｛
    return 需要返回的结果；
｝
函数名（）；

通过return实现将函数运行结果返回给函数的调用者--->函数名（）；
函数名（）= return的结果
				function getMax（num1,num2）{
   return num1 > num2 ？num1 : num2;
}
console.log(getMax( 1,3 ));
				实参较长时（如数组），在开发中将改实参存入一个新变量，方便打印
				函数返回值注意事项
					return 终止函数，返回值后的代码不会被执行
					return 只能返回一个值，解决办法，将需要返回的结果组成数组
function getResult （num1，num2）｛
   return [num1+num2，num1*num2，num1/num2]
｝
var re = getResult（1，2）；
console.log(re);
					函数若没有 return，则返回undefined
			arguments获取函数的参数
				当前函数的一个内置对象，arguments对象中存储了传递的所有实参
function fn(){
  console.log(arguments)  //[1,3,4,6,4,6]
}
getfn([1,3,4,6,4,6]);
				展示的是一个伪数组，并不是真正意义上的数组
1）具有length属性
2）按照索引的方式进行存储
3）没有真正数组的一些方法,pop（）push（）等
				只有函数才有arguments对象，而且每个函数都内置好了这个对象
			函数案例
				resverse   数组翻转任意数组
function reverse（arr）｛
    var newArr=[];
    for (var i = arr.length-1; i >= 0; i-- ){
           newArr[ newArr.length]=arr[i];
}
   return newArr; 
｝

				sort   函数冒泡排序
function sort（arr）｛
     for（var i = 0；i <= arr.length - 1;i++;）｛
          for（var j = 0；j <= arr.length - i - 1; j++;）{
                if(arr[j]<arr[j+1]){
           var temp = 0;
           arr[j] = arr[j+1];
           arr[j+1] = temp;
}            
}
｝
     return arr;
｝
				判断闰年
function isRunYear(year){
       var falg = false；
       if(year % 4 == 0 && year %100 != 0 || year % 400 ==0){
        false = true；
} 
          return falg；
}
					判断当前年份的二月是多少天
闰年29，平年28
function backDay () {
    var year=prompt（‘请输入年份’）；
   if（isRunYear（））｛
       alert（'当前年份是闰年2月份有29天'）
｝else {
       alert ('当前年份是平年2月份有28天')
}
}
backDay（）；
			函数的两种声明方式
				利用函数关键字function自定义函数（命名函数）
				函数表达式（匿名函数）
var 变量名 = fuction（）｛｝；
变量名（）； //调用函数
该表达式调用必须写在函数表达式下面
					变量名不是函数名
					函数表达式声明方式和声明变量差不多，只不过变量里面存储的是值，函数表达式存储的是函数
					函数表达式也可以正常的进行传递参数
		作用域
			JavaScript作用域：代码在某个范围内起作用和效果，目的是为了提高程序的可靠性更重要的是减少命名的冲突，es6之前分两种作用域
				全局作用域
				局部作用域（函数作用域），函数中不能使用全局作用域下的变量
			变量的作用域
				全局变量
注意：如果在函数内部没有声明直接赋值的变量也属于全局变量
				局部变量，只能在局部使用，但局部可以使用全局变量
注意：函数形参也可以看做是局部变量
				从执行效率来看全局变量和局部变量
					1）全局变量只有在浏览器关闭的时候才会销毁，比较占内存资源
2）局部变量在程序执行完毕就会销毁，比较节约内存资源
			js块级作用域
				js中没有块级作用域，es6的时候新增块级作用域
			作用域链
				只要是代码就至少有一个作用域
				卸载函数内部的局部作用域
				如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
				根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称为作用域链
		预解析
			JavaScript解析器在运行JavaScript代码的时候分为两步：预解析和代码执行
				预解析：js引擎会把js里所有的var 还有function 提升到当前作用域的最前面
					变量预解析（变量提升）
就是把所有的变量声明提升到当前的作用域最前面，不提升赋值
console.log(num)；
var num = 10；          //undefined

预解析提升顺序：
var num；
console.log(num)；
num = 10；
--------------------------------------
fun（）；
var fun = function（）｛
     console.log(22);
｝ 
////报错
解析提升顺序：
var fun；
fun（）；
fun = function（）｛
     console.log(22);
｝
					函数预解析（函数提升）
所有函数声明提升到当前作用域的最前面  不调用函数
fn();
function fn(){console.log(11);}   //11
解析提升顺序：
function fn(){console.log(11);}
fn（）；
				代码执行：按照代码书写的顺序，从上到下执行
		对象
			是一组无序的相关属性和方法的集合，所有具体的事物都是对象，例如：字符串、数值、数组、函数等
				属性：事物的特征，在对象中用属性来表示（常用名词）
				方法：事物的行为，在对象中用方法来表示（常用动词）
			创建对象
				字面量创建
					var obj =｛
   username：‘’，
   sex：‘’，
    方法（函数名）：function（）｛//函数体｝
｝
1）属或者方法采用键值对的形式    键 属性名 ：值 属性值，
2）多个属性或者方法中间用逗号隔开
3）方法冒号后面跟的是一个匿名函数
					使用对象
1）调用对象的属性，采用：对象名.属性名   ‘.’ 理解为'的'
console.log(obj.username);
2)调用属性还有一种方法  对象名['属性名']
console.log(obj['sex']);
3）调用对象的方法  对象名.方法名
obj.方法名（）        注：方法名后要加上小括号
				new object
					var obj =  new Object（）；
obj.nsername = ''；
obj.age = '';
obj.sex = '';
obj.方法名 = function（）｛//函数体｝；
					使用对象与字面量对象一致
				构造函数
					前面两种创建方式一次只能创建一个对象，多个对象很多属性和方法大量相同时，抽取出来，构造函数一次可创建多个对象
					function 构造函数名（形参）｛
    this.属性 = 值；
    this.方法 = function () {}
｝
var 对象名 = new 构造函数名(实参)；
					function Star (username,age,sex) {
    this.name = username;
    this.age = age;
    this.sex = sex;
    this.sing = function(){//函数体}
}
var ly = new Star('carly',18,'女');
ly.sing('cook');
1)构造函数 名字首字母要大写
2)构造函数不需要return，就可以返回结果
3）调用构造函数必须使用new
4）只要new Star（）调用函数就是创建一个对象ly｛｝
5)属性和方法前必须要用this
					关键字执行过程
						new 构造函数在内存中创建了一个空的对象
						this 会指向新创建的空对象
						执行构造函数里面的代码，给这个空对象添加属性和方法
						返回这个对象
			遍历对象
				for（变量 in 对象）
				var obj = ｛
      name：‘属性值’，
      age：‘属性值’，
      sex：‘属性值’，
｝

for（var k in obj）｛
  console.log(k)  //k是变量输出，得到的是属性名
    console.log(obj[k] )； //obj[k] 得到的是属性值
｝
				使用for in 里面的变量，一般写 k 或者 key
			内置对象
				js语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或者最基础的而必要的功能（属性和方法）
例如：Math、Date、Array、String等
				查文档
					MDN/W3C
				Math对象
					圆周率 Math.PI（）
					绝对值 Math.abs（）
					向下取整 Math.floor（）
					向上取整 Math.ceil()
					四舍五入 Math.round() 
负数向上取整
console.log(Math.round(-1.1))；    //  -1
console.log(Math.round(-1.5))；    //  -1
					随机数方法 Math.random（）
获取两个数之间的随机整数，包含这两个整数
function random(min, max) {
 
  return Math.floor(Math.random() * (max - min+1)) + min;
 
}
				日期对象
					是一个构造函数，必须使用new来调用创建日期对象
					var date = Math.Date（）；  参数空时为当前现阶段日期
					date.getFullYear();        //返回当前日期的年份
date.getMouth()+1;      //返回月份
date.getDate();            //返回几号
date.getDay();             // 返回星期几对应的数字，周日返回的是‘0’
date.getHours（）；     //时
date.getMinutes();        //分
date.getSeconds（）；//秒
					获取总的毫秒数（时间戳）四种获取方法
date.valueOf();
date.getTime();
简单的写法
var date1 = +new Date();
console.log（date1）；
H5新增的写法
Date.now()
					倒计时案例用时间戳，用户输入时间总的毫秒数减去现在时间的总毫秒数，得到的就是剩余时间的毫秒数
将剩余毫秒数转换为天、时、分、秒
d = parseInt（总秒数/60/60/24）; //计算天数
h = parseInt（总秒数/60/60%24）; //计算小时
m = parseInt（总秒数/60%60）; //计算分数
s = parseInt（总秒数%60）; //计算秒数
				数组对象
					字面量创建
					用newArray（）创建
var arr = newArray(2) //表示新建一个长度为2的数组，但没有数组元素
					检测是否为数组    
Array.isArray 优先级大于instanceof
						1)instanceof 运算符
console.log（arr instanceof Array）；
//true  或者 false
						2)Array.isArray(参数)  ie9以上版本支持
console.log(Array.isAeeay(arr));
//true  或者 false
					添加和删除数组元素的方法
						push（参数1.....）
							参数直接写需要追加的数组元素即可，追加到原数组最后
							push完毕之后，返回的结果是新数组的长度
var arr = [1，2，3]
console.log(arr.push（4）)；//4
						pop（）
							删除数组最后一个元素,一次只能删除一个元素
							小括号里不跟参数
							pop执行结束之后，返回值是删除的元素
console.log(arr.pop());
						unshift（参数1....）
							在数组前面追加新元素
							参数直接写追加的元素
							返回的结果是新数组的长度
var arr = [1，2，3]
console.log(arr.unshift（4）)；//4
							原数据会发生变化
						shift（）
							删除数组最前一个元素，一次只能删除一个元素
							小括号里不跟参数
							shift执行完毕之后，返回值是删除的元素
console.log(arr.shift());
						concat（） 连接两个或多个数组，不影响原数组
						slice（）数组截取slice（begin，end）
						splice（）数组删除splice（第几个开始，要删除的个数），会影响原数组
					数组排序
						reverse（）
							颠倒数组中的元素顺序，无参数
arr.reverse();
						sort（）
							对数组的元素进行冒泡排序
arr.sort();       //只对个位数起效果

//升序的顺序排列
arr.sort(function(a,b){
      return a - b;
})

//降序的顺序排列
arr.sort(function(a,b){
      return b - a;
})
					数组索引方法
						indexOf() 数组中查找给定元素的第一个索引， 如果不存在返回 “-1”。
						IastIndexOf（）  在数组中的最后一个索引，如果不存在返回 “-1”。
						数组去重
function unique(arr){
            var newArray = [];
            for (var i = 0;i < arr.length; i++){
                if(newArray.indexOf(arr[i]) === -1){
                    newArray.push(arr[i]);
                }
            }
            return newArray;
        }
        var demo = unique(['a','c','d','a','b'])
        console.log(demo);
					数组转换为字符串
						toSting（）
						join（‘分隔符’）每个元素用分隔符间隔开
				字符串对象
					基本包装类型
						1)把简单数据类型包装为复杂数据类型
2）再将临时变量的值给 变量
3）销毁这个临时变量
所以对象、复杂类型才有属性和方法，简单数据类型包装后有length属性
						var str = ‘carly’；
// var temp = new String('carly');
// str = temp ;
// temp = null;
					字符串的不可变性
						当你给一个字符串重新赋值之后，老值并没有在内存中销毁，而是重新开辟一块空间存储新值。
						字符串所有的方法，都不会修改字符串本身，操作完成开辟新的空间存储，会返回的是一个新的字符串
					字符返回位置
						indexOf(String str, int index):返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。
					返回字符
						charAt（index）；返回指定位置的字符（index字符串的索引号），用于遍历字符串 str.sharAt(0)
						charCodeAt（index）；获取指定位置处字符创的ASCII码（index索引号）str.charCodeAt(0)
						str[index]；获取指定位置处字符
					字符串操作方法（重点）
						concat（str1.str2.....）用于两个或多个字符串。拼接字符串，等于+，+更常用
						substr（start，length）从start位置开始（索引号），length取的是个数
						slice（start，end）从start位置开始，截取到end位置，end取不到（他们都是索引号）
						substring（start，end）从start位置开始，截取到end位置，end取不到，基本和slice相同，但不接受负值
					其他方法
						替换字符 replace（‘被替换的字符’，‘替换为的字符’）
						字符转换为数组 split（‘分隔符’），这里的分隔符用时取决于原对象中用的什么符号来分割字符，没有分隔符，转换为只有一个元素的数组
var str1 = '1&2&3';
console,log(str1.split('&'))   // [1，2，3]
						转换大写，toUpperCase（）
						转换小写，toLowerCase（）
					简单数据类型和复杂数据类型
						简单数据类型
							值类型 在存储时变量中存储的是值本身
string，number，boolean，undefined， null
							存储到栈中
							简单数据类型传参
						复杂数据类型
							引用类型 在存储变量中存储的仅仅是地址（引用）通过new关键字创建的对象（系统对象 ，自定义对象），如Object，Array，Date等
							存储到堆中，先由栈指向堆
							复杂数据类型传参
	web API
		API：是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节
		web API：是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM），例如直接使用alert就会‘弹出‘
		DOM
			获取元素
				ID获取
					getElementById(‘参数’)，返回一个匹配特定 ID的元素. 由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。
					因为文档是页面是从上向下加载的，所以要先有标签，<script></script>写在标签下
					参数id是大小写敏感的字符串
					返回的是一个元素对象
					console.dir()，打印返回的元素对象，更好的查看里面的属性和方法
				标签名
					document.getElementsByTagName(‘标签名tagname’)，方法可返回带有指定标签名的对象的集合
					返回的是获取过来元素对象的集合，以伪数组的形式存储的
					采取遍历数组的方式获取打印里面的元素对象
for（var i=0；i< lis。length；i++）｛
   console.log（lis[ i ]）;
｝
					若页面中只有一个需要获取的元素或者没有，返回的还是伪数组形式
					element.getElementsByTagName(‘标签名tagname’)，获取某个元素（父元素）内部所有指定标签名的子元素，注：父元素必须是单个对象（必须指明是哪一个元素对象），获取的时候不包括父元素自身
				html5新增方法获取
					document.getElementsByClassName(’类名example’)，方法返回文档中所有指定类名的元素集合
					document.querySelector（’选择器’），根据指定选择器返回第一个元素对象，选择器写的时候带符号，id带“#”，class带“.”
					document.querySelectorAll（’选择器’）,根据指定选择器返回所有元素对象集合，选择器写的时候带符号，id带“#”，class带“.”
				特殊元素获取
					获取body元素
document.body，
获取html元素
document.documentElement
			事件基础
				事件概述，触发...响应机制
				事件三要素
					事件源，事件被触发的对象
					事件类型，如何触发什么事件，例如鼠标点击（onclick）
					事件处理程序，通过一个函数赋值的方式完成
					执行事件过程
						获取事件源
						注册事件（绑定事件）
						添加事件处理程序
				常见的鼠标事件
					onclick 单击事件（相继触发mousedown与mouseup事件）
onmousedown 鼠标按下事件
 onmouseup 鼠标抬起事件
onmousemove 鼠标移动事件
 onmouseout 鼠标移出事件
 onmouseover 鼠标指针移动到元素（被选元素或其子元素）上时触发常与onmouseout一起用

onmouseenter 只有在鼠标指针穿过被选元素时，才会触发，常与onmouseleave一起使用

 onmouseleave 鼠标移出事件
onfocus  获得鼠标焦点触发
onblur    失去鼠标焦点触发
				操作元素
					操作元素内容
						element.innerText,从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉，不识别html标签
						element.innerHTML，起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行，识别html标签
div.innerHTML = '<strong>hello</strong>';
					表单元素的属性操作
						利用DOM可操作如下表单元素属性：type，value，checked，selected，disabled
						表单里的值，是通过value来修改的，不能用innerHTML
btn.onlick = function () {
             this.disabled = true;  //禁用，this指向的是事件函数的调用者
}
					样式属性操作
						通过js修改元素的大小，颜色，位置等样式
element.style             //里面的属性采用驼峰命名法，eg：this.style.backgroundColor，修改后产生的是行内样式，css权重比较高
						element.className   //如果样式修改的过多，可以采用操作类名的方式修改，class是个保留字，所以用className来操作元素类名属性，className会直接修改元素的类名，覆盖原先的类名
					H5自定义属性
						自定义属性是通过geAttribute（‘属性’）获取的
但是有些自定义属性很容易引起歧义，不容易判断是内置属性还是自定义属性
H5规定自定义属性 data- 开头的作为属性名并赋值
eg：<div data-index='1'></div>
或者使用js设置
element.setAttribute（‘data-index’，2）
						dataset 是一个集合，里面存放了所有以data-开头的自定义属性
				节点操作
					DOM提供的方法获取元素
						document.getElementById（）
						document.getElementByTagName（）
						document.querySelected（）
					利用节点层次关系获取元素
						利用父子兄弟节点关系获取元素
						逻辑性强，但兼容性差一点
					节点层级
						父节点 node.parentNode，获取的是最近的一个父节点（亲爸爸）
						子节点
							子节点 node.childNodes ，所有的子节点，包含元素节点、文本节点等
								parentNode.children，非标准获取子元素节点，是实际开发中用
							第一个子元素和最后一个子元素

								firstChild，lastChild
								firstElementChild，lastElementChild
								实际开发写法，
children[ i ]
children[node.children.length - 1]
							兄弟节点
								包含元素节点或者文本节点
									node.nextSinling
									node.previousSibling
								只获取元素节点
									node.nextElementSinling
									node.previousElementSibling
								如何解决兼容性
									封装兼容性函数
————————————————
 function getElementSibling(element) {
            var el = element;
            while (el = el.nextSibling) {
                if (el.nodeType === 1) {
                    return el;
                }
            }
            return null;
        }
					创建添加节点
						在最后创建添加
							var li = document.createElement（‘li’）
							var ul = document.appendChild（‘ul’）；
ul.appendChild（li）；
						指定位置添加
							node.insertBefor(child,指定元素)
var li = document.createElement('li');
ul.insertBefore(li,ul.children[ 0 ]);
					复制节点
						node.cloneNode();克隆后需要添加在页面中
						浅拷贝：括号为空或者false
深拷贝：括号为true
					删除节点
						node.removeChild(node.children[i]);
					三种动态创建元素的区别
						document.write('<div>123</div> ');文档流加载完毕再调用，其他节点会被清除,页面重绘
						innerHTML,将内容写入某个DOM节点，不会导致页面重绘。
var div = document.querySelector('div');
for(var i= 0; i<= 100; I++){
   div.innerHTML += "<a href='#'>hello world</a>";
}
创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
var arr = [];
for(var i = 0;i <= 100; I++){
          arr.push("<a href='#'>hello world</a>")
}
     div.innerHTML = arr.jion('');
						document.createElement()，效率低，结构清晰
var ul = document.appendChild（‘ul’）；
ul.appendChild（li）；
				DOM的重点核心
					文档对象模型，是W3C组织推荐的处理可扩展标记语言(HTML或者XML)的标准编程接口。

W3C定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式

对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口
对于HTML，dom使得html形成一棵dom树，包含文档、元素、节点
注意：

我们获取过来的DOM元素是一个对象(object),所以称为文档对象模型
					关于dom操作，主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作

1. 创建
document.write
innerHTML
createElement
2. 增
appendChild：在后面添加
insertBefore：在前面添加
3. 删
removeChild
4.改
主要修改dom的元素属性，dom元素的内容，属性，表单的值等

修改元素的属性：src、 href 、 title等
修改普通元素内容：innerHTML、innerText
修改表单元素：value、type、disabled等
修改元素样式：style、className
5. 查
主要获取查询的dom元素

DOM提供的API方法：getElementById、getElementByTagName等 古老用法不太推荐
H5提供的新方法：querySelector、querySelectorAll 提倡
利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling、nextElementsibling) 提倡
6. 属性操作
主要针对于自定义属性。

setAttribute：设置dom的属性值
getAttribute：得到dom的属性值
removeAttribute：移除属性
7. 事件操作
给元素注册事件

事件源.事件类型 = 事件处理程序：如div.onclick = function() {}
addEventListener() ：如div.addEventListener(‘click’, function() {}, true/fasle)
attachEvent()：如div.attachEvent(‘onclick’, function() {})
————————————————
			事件高级
				注册事件（绑定事件）
					概述：给元素添加事件，称为注册事件，有两种方式：传统方式和方法监听注册方式
						传统式：
利用on开头是的事件，onclick
<button onclick='alert('123')'></button>
btn.onclick = function(){}
特点：唯一性
同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数
						监听事件：
addEventListener（）
IE之前的IE不支持该方法，可以用attachEvent（）代替
特点：同一个元素同一个事件可以注册多个监听器
里面的事件类型是字符串，必须加引号，不带onaddEventListener("click", function()｛｝
							解决兼容性问题
function addEvent(obj,ev,fn) //obj为要绑定事件的元素，ev为要绑定的事件，fn为绑定事件的函数
{
	 if(obj.addEventListener){
			obj.addEventListener(ev,fn,false);
	}else if(obj.attachEvent){
		    obj[ev+fn] = function(){
	 				fn.call(obj);
			 		}
			obj.attachEvent("on" + ev,obj[ev+fn]);
	 }else {
			obj['on'+type]=fn;
	 }}
function removeEvent(obj,ev,fn)
{
	 if(obj.removeEventListener){
			 obj.removeEventListener(ev,fn);
		}else if(obj.detachEvent){
			obj.detachEvent("on" + ev, obj[ev+fn]);
		 		}
		 }else {
			obj['on'+type]=null;
	 }}
————————————————
				删除事件（解绑事件）
					传统方式
eventTarget.onclick = null;
					方法监听注册方式删除（addEventListener注册的事件删除）
eventTarget.removeEventListener(type, listener[, useCapture])
					attachEvent注册的事件删除
eventTarget.detachEvent(‘onclick’, fn);
				DOM事件流
					接受事件的顺序，事件发生时会在元素节点之间按照特定的顺序传播，这个过程为DOM事件流
					分为三个阶段
1.捕获阶段
2.当前目标阶段
3.冒泡阶段
						js只获取捕获阶段或者冒泡阶段中的一个
						onclick和attachEvent（ie）只能得到冒泡阶段
						addEVentListener（type，listerner[ , useCapture]）第三个 参数如果是true，表示在时间捕获阶段调用时间处理程序；如果是false（不写默认false），表会死在时间冒泡阶段调用时间出路程序
						实际开发只能怪很少使用时间捕获，更关注事件冒泡
				事件对象
					var div = document.querySelector('div');
div.onclick = function(event){
    console.log(event)
}

						1.event就是一个事件对象（可自己命名evt，e），写到监听函数的，小括号里面，当形参看
2.事件对象只有有了事件才会存在，是系统自动传参的，不需要传递参数
3.事件对象是事件的一系类相关数据的集合，跟事件相关的，比如鼠标点击里面包含了师表的相关信息
						兼容性解决：e = e || window.event;
					常见事件对象的属性和方法
						e.target 返回的是触发事件的对象（元素），this返回的是绑定事件的对象
						常见的属性和方法
				阻止事件冒泡
					e.stopPropagation();
					解决兼容性:加上  e.cancelBubble = true;
					event.preventDefault()可以取消默认事件
				事件委托（代理，委派）
					不是每个子节点单独设置事件监听器，耳饰事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节·
值操作了一次DOM，使效率提高
					window.onload = function(){
    var oUl = document.getElementById("ul1");
   oUl.onclick = function(){
        alert(123);
    }
}
				常用鼠标事件
				常用键盘事件
		BOM
			BOM概述
				浏览器对象模型，提供独立于内容而与浏览器窗口进行交互的对象，其核心对象是window，构成包含了DOM
				构成：
window对象是浏览器的顶级对象，具有双重角色
1.shi JS访问浏览器窗口的一个接口
2.是一个全局对象，定义在全局作用域中的变量、行数都会变成window对象的属性和方法。在调用的时候可省略window，前面学习的对话框都属于window对象方法，入alert（）、prompt（）等
			window对象的常见事件
				窗口加载事件
					window.onload = function(){}
或者
window.addEventListener("load",function(){});
					document.addEventListener('DOMContentLoaded',function(){});
				调整窗口大小
					window.onresize = function(){}；
window.addEventListener("resize",function(){});
					window.innerWidth,屏幕尺寸
			定时器
				window.setTimeout（调用函数，延迟的毫秒数）
1.在调用的时候可以省略window
2.延时事件的单位是毫秒，可以省略，默认是0
3.调用的函数可以直接写函数，还可以写函数名，还有一种写法 ‘ 函数名（）’，第三种不推荐
4.页面中肯有很多定时器，可以用变量存一个标识符
					清除定时器
window.clearTimeout(timeout ID)
window可以省略
				setInterval（回调函数，间隔的毫秒数）；
1.window可以省略
2.这个调用函数可以直接写函数，或者写函数名，或者采用字符串 ‘ 函数名（） ’三种形式
3.间隔的毫秒数省略默认是0，必须写，必须是毫秒，表示每间隔多少毫秒就自动调用这个函数
4.因为定时器可能很多，所以经常给定时器赋值一个标识符
					清除定时器
window.clearInterval(timeout ID)
window可以省略
定时器名必须为全局变量
var timer = null；
				this的指向问题，一般情况下最终指向的是哪个调用它的对象
					1.全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）
					2.方法调用中谁调用this指向谁
					3.构造函数中this指向构造函数的实例
			JS执行机制
				JS是单线程
				同步和异步
					本质：各个流程的执行顺序不一样
					同步任务都在主线程上执行，形成一个执行栈
异步任务通过回调函数实现
    一般而言，异步任务有以下三种类型
1.普通事件，click、resize等
2.资源加载 ，load、error等
3.定时器，setTimeout、setInterval等
异步任务相关回调函数添加到任务队列中（任务队列也成为消息队列）
				执行机制
					先执行执行栈中的同步任务
					异步任务（回调函数）放入任务队列中
					一旦执行栈所有同步任务执行结束，系统会按次序开始执行任务队列中的一部任务于是被读取的一部任务结束等待状态，进入执行栈开始执行
					事件循环：栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调，如此循环
			location对象
				概念：window对象给我们提供了一个loction属性用于获取或设置窗体的URL，并且可以用于解析URL。因为这个属性返回的是一个对象，所以我们将这个属性称为loction对象
				URL：统一资源定位符
				loction对象的属性
hash	设置或返回从井号 (#) 开始的 URL（锚）。
host	设置或返回主机名和当前 URL 的端口号。
hostname	设置或返回当前 URL 的主机名。
href	设置或返回完整的 URL。
pathname	设置或返回当前 URL 的路径部分。
port	设置或返回当前 URL 的端口号。
protocol	设置或返回当前 URL 的协议。
search	设置或返回从问号 (?) 开始的 URL（查询部分）。
				loction对象的方法
assign()	载入一个新的文档，记录浏览历史，可实现后退页面
replace()	用新的文档替换当前文档不记录历史，不能后退
reload()	重新载入当前文档
			navigator对象
				navigator为Window对象的一个属性，指向了一个包含浏览器相关信息的对象。navigatot中包含了一些常用到的属性，如   

navigator.appVersion 浏览器的版本号 

navigator.appName 浏览器的名称 

navigator.language 浏览器使用的语言 

navigator.platform 浏览器使用的平台 

navigator.userAgent 浏览器的user-agent信息
————————————————
				navigator.userAgent用来区分设备和浏览器，pc端或者移动端布局展示
<script>
        if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
            window.location.href = "../H5/index.html"; //手机
        }
    </script>
			history对象
				back()	加载 history 列表中的前一个 URL。
forward()	加载 history 列表中的下一个 URL。
go()	加载 history 列表中的某个具体页面。
		PC端网页特效
			元素偏移量offset系列
				元素偏移量offset常用属性
					offsetTop  返回元素距离带有定位的父级顶部的距离，不带单位
					offsetLeft  返回元素距离带有定位的父级左侧的距离，不带单位
					offsetWidth  返回元素自身的宽度，包括padding、border、width，不带单位
					offsetHeight  返回元素自身的高度，包括padding、border、width，不带单位
					offsetParnet  返回带有定位的父亲，没有则返回body
				获取元素位置
				offset与style区别
					offset：
可以得到任意样式表中的样式值
系列获取的数值没有单位
offsetWidth包含padding+border+width
系列属性只读属性，只能获取不能赋值
所以要想获取元素大小位置，用offset更合适
					style：
只能得到行内表中的样式值
style.width获取带有单位的字符串
style.width获取不包含padding+border的值
style.width是可读写属性，可以获取也可以赋值
想要给元素更改值，则需要用style改变
			元素可视区client系列
				元素可视区client系列属性
					element.clientTop
返回元素上边框的大小
					element.clientLeft
返回元素左边框的大小
					element.clientWidth
返回自身包括padding、内容区的宽度、不含边框，返回数值不带单位。
					element.clientHeight
返回自身包括padding、内容区的高度、不含边框，返回数值不带单位。
				获取元素大小
				立即执行函数
					（function（）｛｝）（）;
					(function(){} ());
					不需要调用，立马执行
括号可以传参
创建了独立的作用域，避免了命名冲突问题
			元素滚动scroll系列
				元素滚动scroll系列属性
					element.scrollTop
返回被卷去的上侧距离，返回数值不带单位
					element.scrollLeft
返回被卷去的左侧距离，返回数值不带单位
					element.scrollWidth
返回自身实际宽度，不含边框，返回数值不带单位
					element.scrollHeight
返回自身实际高度，不含边框，返回数值不带单位
				获取滚动距离
					页面的滚动距离：window.pageYOffset
			mouseover和mouseenter两个事件的区别
				mouseover(鼠标覆盖)
				mouseenter(鼠标进入)
			动画函数封装
				function animate(obj,target){};
animate(obj,target);

//obj是目标对象,target是目标位置
			常见网页特效
				PC端
					轮播图
					节流阀
					短路应用回调函数：callback && callback（）；
				移动端
					触屏事件
						常见的属性：
touchstart:     //手指放到屏幕上时触发

touchmove:      //手指在屏幕上滑动式触发

touchend:    //手指离开屏幕时触发

touchcancel:     //系统取消touch事件的时候触发，这个好像比较少用
						触摸事件对象
touches   正在触摸屏幕的所有手指列表
targetTouches  正在触摸当前DOM元素所有手指列表
changeTouches   手指状态发生了改变的列表，从无到有   或者从有到无
					常见特效
						轮播图
		本地存储
			sessionStorage
				生命周期为关闭浏览器窗口
				在同一个窗口（页面）下数据可以共享
				以键值对的形式存储使用
				存：
sessionStorage.setItem("key", "value");
查：
sessionStorage.getItem("key");
删：
sessionStorage.removeItem("key");
删除所有数据：
sessionStorage.clear();
			localStorage
				生命周期永久生效，除非手动删除，否则关闭页面也会存在
				可以多窗口（页面）共享（同一浏览器可以共享）
				以键值对的形式存储使用
				存：
localStorage.setItem("key", "value");
查：
localStorage.getItem("key");
删：
localStorage.removeItem("key");
删除所有数据：
localStorage.clear();
	jQuery
		概述：
是一个 JavaScript 库。
极大地简化了 JavaScript 编程。
			常见的JS库：
jQuery
prototype
YUI
Dojo
Ext JS
移动端的zepto
		基本使用
			页面加载事件解决，入口函数
				$(function(){
       ..... // do something  页面DOM加载完成的入口
});
				$(document).ready(function(){
       ....   //do something 页面DOM加载完成的入口
})
				等着DOM结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery帮我们完成了封装
相当于原生js中的DOMContentLoaded
不同于原生js中的load 事件是等页面文档、外部的js文件、css文件、图片加载完毕才执行内部代码
			顶级对象 : $
				$是JQuery的别称,在代码中可以使用JQuery代替 $,但一般为了方便,通常都直接使用$
				$是JQuery的顶级对象,相当于原生JavaScript中的windows,把元素利用$包装成JQuery对象,就可以调用JQuery的方法.
			jQuery对象和DOM对象
				通过DOM获取就是DOM对象
var obj1 = document.querySelector（‘div’）
通过$或者jQuery获取就是jQuery对象
var obj2 = $（'div'）;
				jQuery对象只能使用jQuery方法，DOM对象则使用原生的JavaScript 属性和方法
				DOM对象与jQuery对象之间是可以互相转换的
					DOM对象转换为jQuery对象
$(DOM对象)
					jQuery对象转换为DOM对象
						$('div')[index]   //index是索引号
						$('div').get(index)   //index是索引号
		jQuery常用API 
			选择器
				id选择器 

$(“#ids”)其中的ids是一个标签的id值而$(“#ids”)就是满足条件的那个标签！

类选择器

$(".myclass")其中的myclass就是class="myclass"的值，而$(".myclass")就是获取类为myclass的所有标签，有可能是一个标签有可能是多个

元素选择器

$("div") 就是选择所有的div标签。

通配符选择器

$("*") 选择页面上的所有元素

逗号分隔

$("#ids",".myclass") 选择id为ids 和 类为myclass的标签
				层级选择器
子代选择器：$( ' ul > li ' );
后代选择器：$( ' ul li ' );
				筛选选择器
					：first   $（‘li:first’）  //获取第一个li元素
：last    $（‘li:last’）  //获取最后一个li元素
：eq（index） $（‘li:eq（2）’） //获取到的li元素中，选择索引号为2的元素，索引号index从0开始
：odd    $（‘li:odd’） //获取到的li元素中，选择索引号为奇数的元素
：even   $（‘li:even’） //获取到的li元素中，选择索引号为偶数的元素
					parent()  亲父级元素
children()  子级元素，相当于子代选择器
find()  后代选择器
siblings()　　　　//兄弟元素
.nextALL()　　　　//查找当前元素之后的所有兄弟元素
.prevALL()　　　　//查找当前元素之前的所有兄弟元素
hasClass（class） //检查当前元素是否航油某个特定的类，如果有，则返回true
eq（index）  //相当于$(‘li：eq（2）’)，index从0开始
				隐式迭代：
在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用,这就叫做隐式迭代
				排他思想：当前元素设置样式，其余的兄弟元素清除样式
				链式编程：
$(this).css("color","red")siblings().css("color","");
$("div").eq(index).show().siblings().hide();
			样式操作
				操作css方法
					css(name,value) 方法设置或返回被选元素的一个或多个样式属性。
$('div').css('width','300px')
$("p").css({"background-color":"yellow","font-size":"200%"});
					name:
必需。一定加引号，规定 CSS 属性的名称。该参数可包含任何 CSS 属性，比如 "color"。参数可以是对象形式
value:	
可选。规定 CSS 属性的值。该参数可包含任何 CSS 属性值，比如 "red"。
如果设置了空字符串值，则从元素中删除指定属性。
值如果是数字，可以不用跟单位和引号
参数是对象形式，值为复合属性要加引号
background：“red”，
				设置类样式方法，不影响原先的类名
					$("div").addClass("className")
					$("div").removeClass("className")
					$("div").toggleClass("className")
			效果
				显示隐藏
					语法规范
						show（[speed,[easing],[fn]]）；
hide（[speed,[easing],[fn]]）;
toggle（[speed,[easing],[fn]]）;
						显示参数
参数可以省略，无动画直接显示
speed：三种预定速度之一的字符串（‘slow’，“normal”，‘fast’）或表示动画时长的毫秒数值，如：1000.
easing：（optional）用来指定切换效果，默认是“swing”，可用参数“linear”
fn：回调函数，在动画完成时执行的函数，每个元素执行一次
				滑动
					语法规范
						slideUp（[speed,[easing],[fn]]）；
slideDown（[speed,[easing],[fn]]）;
slideToggle（[speed,[easing],[fn]]）
						显示参数
参数可以省略，无动画直接显示
speed：三种预定速度之一的字符串（‘slow’，“normal”，‘fast’）或表示动画时长的毫秒数值，如：1000.
easing：（optional）用来指定切换效果，默认是“swing”，可用参数“linear”
fn：回调函数，在动画完成时执行的函数，每个元素执行一次
					事件切换hover（）
						$(a).hover(function(){
$(this).children("ul").slideToggle();
});
					动画排队问题解决：stop（） //此方法必须写在动画的前面，相当于停止上一次动画
				淡入淡出
					语法规范
						fadeIn（[speed,[easing],[fn]]）；
fadeOut（[speed,[easing],[fn]]）;
fadeToggle（[speed,[easing],[fn]]）;
fadeTo（[speed,opacity,[easing],[fn]]）;
						显示参数
参数可以省略，无动画直接显示
speed：三种预定速度之一的字符串（‘slow’，“normal”，‘fast’）或表示动画时长的毫秒数值，如：1000.
opacity:透明度
easing：（optional）用来指定切换效果，默认是“swing”，可用参数“linear”
fn：回调函数，在动画完成时执行的函数，每个元素执行一次
				自定义动画
					语法规范
						animate（｛params｝，[speed,[easing],[fn]]）；

						显示参数
参数可以省略，无动画直接显示
params：想要修改的样式属性，以对象形式传递，必须写。属性名可以不带引号，如果是复合属性则需要采用驼峰命名法，其余参数可以省略
speed：三种预定速度之一的字符串（‘slow’，“normal”，‘fast’）或表示动画时长的毫秒数值，如：1000.
easing：（optional）用来指定切换效果，默认是“swing”，可用参数“linear”
fn：回调函数，在动画完成时执行的函数，每个元素执行一次
			属性操作
				设置或获取元素固有属性值 prop（） 
//$("a").prop（“href”）    
$("a").prop("title","####")
				设置或获取自定义属性值 attr（）

相当于原生的getAttribute（）和setAttribute（）
该方法也可以获取h5自定义属性
// $("div").attr("index")
$("div").attr("index","2")
				数据缓存data（），这个里面的数据是缓存到元素的内存里面，获取h5自定义属性data-index，第一个不用写data- ，而且返回的是数字类型
			文本属性值
				主要是针对元素内容和表单值操作

				获取设置普通元素内容html（）（相当于原生innerHTML）
				获取设置普通元素文本内容 text（）（相当于原生innerText）
				获取设置表单值val()（相当于原生value）
			元素操作
				增删改查
				遍历元素：each（）
针对同一类元素做不同的操作，需要用到遍历元素（类似for，但是比for强大）

$("div").each(fuction(index,domEle){xxx};)

1.each()方法遍历匹配的每一个元素。主要用DOM处理，each每一个
2.里面的回调函数有两个参数：index是每个元素的索引号；domELe是每个DOM元素对象，不是jQuery对象
3.所以想要使用jQuery方法，需要对这个dom元素转换为jQuery对象$（domEle）
				遍历数组、对象：$.each()

$.each(object，function（index，element）｛xxx；｝)

1.$.each（）方法可用于遍历任何对象，主要用于数据处理，比武数组、对象
2.里面的函数有了个参数：index是每个元素的索引号；element遍历内容
				添加元素
					内部添加
						把内容放到element子级的最后面：element.append("内容")
						把内容放到element子级的最前面：element.prepend("内容")
					外部添加
						把内容放到element同级元素的最后面：element.after("内容")
						把内容放到element同级元素的最前面：element.before("内容")
				删除元素
					element.remove（） 删除匹配的元素
					element.empty()  删除匹配元素的子节点
					element.html("")  删除匹配的元素的子节点
			尺寸、位置操作
				尺寸
					width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。
					height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。
					innerWidth() 方法返回元素的宽度（包括内边距）。
					innerHeight() 方法返回元素的高度（包括内边距）。
					outerWidth() 方法返回元素的宽度（包括内边距和边框）。
					outerHeight() 方法返回元素的高度（包括内边距和边框）。
					outerWidth(true) 方法返回元素的宽度（包括内边距和边框、margin）。
					outerHeight(true) 方法返回元素的高度（包括内边距和边框、margin）。
				位置
					offset()获取设置匹配元素在相对浏览器窗口的偏移量
					position()获取匹配元素在相对带有定位的父元素的偏移量，如果没有定位的父级，则以文档为准
					scrollTop() 　　　获取匹配元素距离滚动条顶部的距离，说白了就是边框的最顶部与当前显示出来的最顶部的距离。

　  scrollTop(val)　　设置匹配元素距离滚动条顶部的距离
					scrollLeft()　　   获取匹配元素距离滚动条顶部的距离,说白了就是边框的最左边与当前显示出来的最左边的距离。

　  scrollLeft(val)　 设置匹配元素距离滚动条顶部的距离
		jQuery事件
			jQuery事件注册
				单个事件注册 ：click、mouseenter....
			jQuery事件处理
				事件处理 on（）方法在匹配元素上绑定一个或多个事件的事件处理函数
					on可以实现事件委派（委托）
$(document).on('click','.btn2',function(){}
					on可以给未来动态创建的元素绑定事件
					element.on(events,[selector],fn)
1.events：一个或多个用空格分隔的事件类型，如‘click’、‘keydown’
2.selector:元素的子元素选择器
3.fn:回调函数，即绑定在元素上的侦听函数
				事件解绑 off（） 
					$('p').off()  //解绑p元素所有的事件处理程序
					$('p').off("click")    // 解绑p元素上面的点击事件，后面的off是监听函数名 
					$('p').off("click","li")  //解绑事件委托
				事件只触发一次 one（）
				自动触发事件
					元素.事件（）  $("div").click()
					自动触发事件trigger（“事件”），例如轮播图自动播放跟点击右侧按钮功能一致
					triggerHandler（“事件”）不会触发元素的默认行为
			jQuery事件对象
				事件被触发，就会有事件对象的产生
element.on（eventment，【selector】，function（event）｛｝）
				阻止默认行为：event.preventDefault（）或者return false
				阻止冒泡：event.stopPropagation（）
		jQuery的其他方法
			jQuery对象拷贝
				语法：$.extend（【deep】，target，object1，【objectN】）
				deep：设置为true为深拷贝，默认是false浅拷贝
				traget:要拷贝的目标对象
				object1：待拷贝到第一个对象的对象
			多库共存
				jQuery使用$作为标识符，随着jQuery的流行，其他js库也会用$作为标识符，这样一起使用会引起冲突
				需要一个解决方案，让jQuery和其他的js库不存在冲突，可以同时存在，这就是多库共存
				1.把里面的$符号统一改为jQuery。比如jQuery（“div”）
2.jQuery变量自定义名称 ：$.noConflict()   var xxx = $.noConflict();
			jQuery插件
				jQuery插件库：https://www.jq22.com/
				jQuery之家：http://www.htmleaf.com/
				fullPage.js插件：https://www.dowebok.com/
				bootstrap JS 组件插件
